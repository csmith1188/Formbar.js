{% extends 'header_fullscreen.html' %}
<!-- ^^ This means add this file into the contents of the header page -->
<!-- This is where the title, top buttons, and stylesheet is located -->

<!-- Change title here -->
{% block title %}Blewnz{% endblock %}

<!-- Extra style declarations here -->
{% block style %}
  <style>
    body {
      background: var(--bg-darker);
      user-select: none;
    }

    #container {
      aspect-ratio: 16 / 9;
      outline: 1px solid var(--dark-gray);
      overflow: hidden;
      text-align: left;
    }

    @media (max-aspect-ratio: 16/9) {
      #container {
        width: 100%;
        font-size: calc(5vw / 6);
      }
    }

    @media (min-aspect-ratio: 16/9) {
      #container {
        height: 100%;
        font-size: calc(40vh / 27);
      }
    }

    #game {
      position: absolute;
      width: 100%;
      background: linear-gradient(to bottom right, #040, #400, #004);
      background-size: 100%;
    }

    button:not(.inline) {
      background: transparent;
    }

    button:not(.inline):not(.unselectable):hover {
      background: #fff2;
    }

    #progress {
      position: absolute;
      left: 1.5%;
      top: calc(24% / 9);
      width: 100%;
      color: var(--light-blue);
    }

    #progressText {
      font-size: 250%;
    }

    #achievements {
      margin-top: 1%;
      font-size: 200%;
    }

    #achvButton {
      margin-left: 0.75%;
      font-size: 75%;
    }

    .complete {
      color: var(--light-yellow) !important;
    }

    .complete span, .complete button:not(:hover) {
      filter: drop-shadow(0 0 5px #fffa);
    }

    #back {
      position: absolute;
      left: 0%;
      top: 0;
      width: calc(75% / 16);
      height: calc(75% / 9);
      padding: 0;
      text-align: center;
      font-size: 400%;
      line-height: 130%;
      color: white;
      cursor: pointer;
    }

    #prevMap {
      position: absolute;
      left: 15%;
      top: calc(250% / 9);
      width: calc(75% / 16);
      height: calc(75% / 9);
      padding: 0;
      text-align: center;
      font-size: 400%;
      line-height: 130%;
      color: var(--light-cyan);
      cursor: pointer;
    }

    #nextMap {
      position: absolute;
      right: 15%;
      top: calc(250% / 9);
      width: calc(75% / 16);
      height: calc(75% / 9);
      padding: 0;
      text-align: center;
      font-size: 400%;
      line-height: 130%;
      color: var(--light-cyan);
      cursor: pointer;
    }

    #prevMap:active, #nextMap:active {
      color: white;
    }

    #difficulty {
      position: absolute;
      left: 0;
      top: 56%;
      width: 100%;
      text-align: center;
      font-size: 200%;
    }

    #normal, #hard {
      padding: 0.25% 1%;
      margin: 0 0.5%;
      border: 1px solid;
      border-radius: 9999px;
      font-size: calc(inherit x 0.75);
      font-weight: 500;
    }

    #normal {
      color: var(--light-green);
    }

    #normal.pressed {
      background: var(--light-green);
      border-color: var(--light-green);
      color: var(--bg-dark);
    }

    #hard {
      color: var(--light-orange);
    }

    #hard.pressed {
      background: var(--light-orange);
      border-color: var(--light-orange);
      color: var(--bg-dark);
    }

    #startButton {
      position: absolute;
      bottom: 5%;
      padding: 0.25% 1%;
      color: var(--light-cyan);
      border: 1px solid;
      border-radius: 9999px;
      font-size: 200%;
      font-weight: 500;
    }

    #grid {
      position: absolute;
      top: 0;
      width: 100%;
      aspect-ratio: 32 / 15;
      border-collapse: collapse;
    }

    table, td {
      border: none;
    }

    td {
      width: calc(100% / 32);
    }

    .visibleLines td {
      border: 1px solid #555;
    }

    td.gameButton {
      cursor: pointer;
    }

    td.droppable {
      background: #aaa5;
    }

    td.undroppable {
      background: #a555;
    }

    td.tower {
      cursor: pointer;
    }

    #alert {
      position: absolute;
      width: 30%;
      height: 30%;
      padding: 1.5%;
      box-sizing: border-box;
      background: #cccc;
      color: var(--bg-dark);
      font-size: 150%;
      text-align: left;
      filter: drop-shadow(10px 10px 5px black);
    }

    #alert.large {
      height: 50%;
    }

    #alert.error b {
      color: var(--color-red);
    }

    #alertText {
      position: absolute;
      top: calc(5% * 16 / 9);
      left: 5%;
      width: 90%;
      height: 50%;
      overflow: auto;
    }

    #alert.large #alertText {
      top: calc(5% * 16 / 15);
      height: 70%;
    }

    #alert h1 {
      margin: 0 0 3% 0;
      font-size: 125%;
      font-weight: normal;
    }

    li.earned::marker {
      content: "ðŸ—¸  ";
    }

    #ok {
      position: absolute;
      left: 40%;
      bottom: 10%;
      width: 20%;
      height: 20%;
      padding: 0.25% 1%;
      background: white;
      color: var(--color-blue);
      border: 1px solid;
      border-radius: 9999px;
      font-size: calc(400% / 3);
      font-weight: 500;
      filter: drop-shadow(2px 2px 1px #000c);
    }
    
    #alert.large #ok {
      height: 12%;
      bottom: 6%;
    }

    #ok:hover {
      background: white !important;
      filter: brightness(90%) drop-shadow(2px 2px 1px #000a);
    }

    .menu {
      position: absolute;
      min-width: 15%;
      max-width: 20%;
      padding: 0.5%;
      box-sizing: border-box;
      background: #cccc;
      color: var(--bg-dark);
      text-align: center;
      filter: drop-shadow(10px 10px 5px black);
    }

    .splitButton {
      color: var(--color-green);
      border: 1px solid;
      border-radius: 4px;
      font-size: 80%;
      font-weight: 500;
      filter: drop-shadow(2px 2px 1px #000c);
    }

    .splitButton:not(.unselectable) {
      cursor: pointer;
    }

    .buttonLeft {
      width: fit-content;
      padding: 0 1.5%;
      border-radius: 4px 0 0 4px;
      background: white;
    }

    .buttonRight {
      width: fit-content;
      padding: 0 1.5%;
      border-radius: 0 4px 4px 0;
      background: var(--color-green);
      color: white;
    }

    .splitButton:not(.unselectable):hover {
      filter: brightness(90%) drop-shadow(2px 2px 1px #000a);
    }

    .sellButton {
      color: var(--color-red);
    }

    .sellButton .buttonRight {
      background: var(--color-red);
    }

    .bought .buttonLeft {
    border-radius: 4px;
    }

    .bought .buttonRight {
      display: none;
    }

    .menu h1 {
      margin: 0 0 4% 0;
      font-size: 150%;
      font-weight: normal;
    }

    .menu h2 {
      margin: 3% 0 0 0;
      font-size: 125%;
      font-weight: normal;
    }

    #towers {
      position: absolute;
      bottom: 0;
      width: 100%;
      aspect-ratio: 32 / 3;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 5%;
      background: #0005;
      border-top: 1.5px solid var(--light-gray);
      cursor: default;
    }

    #towers img {
      height: calc(100% / 3);
    }

    #towers img:not(.unselectable):hover {
      cursor: grab;
      filter: drop-shadow(0 0 6px white);
    }

    #towers img:not(.unselectable):active {
      cursor: grabbing;
    }

    #towers img.unselectable {
      opacity: 25%;
    }

    #towerDesc {
      position: absolute;
      top: 5%;
      width: 100%;
      text-align: center;
      font-size: 150%;
    }

    #powers {
      position: absolute;
      bottom: 10%;
      width: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 3%;
      text-align: center;
    }

    #powers button {
      width: 5.125%;
      padding: 0.1% 0.3%;
      font-size: 100%;
    }

    .invisible {
      visibility: hidden;
    }
    
    .powerReady {
      animation: powerReady 1s;
    }

    @keyframes powerReady {
      12.5% {
        transform: rotate(1deg);
      }
      37.5% {
        transform: rotate(-2deg);
      }
      50% {
        background: #fff2;
        color: white;
      }
      62.5% {
        transform: rotate(2deg);
      }
      87.5% {
        transform: rotate(-1deg);
      }
    }
  </style>
{% endblock %}

<!-- Main content here -->
{% block main %}
  <div id="container" class="centered">
    <canvas id="game" width="1920" height="1080"></canvas>
    <div id="progress"></div>
    <table id="grid" class="hidden"></table>
    <div id="towers" class="hidden">
      <div id="towerDesc"></div>
      <div id="powers"></div>
    </div>
  </div>
{% endblock %}

<!-- Extra javascript here -->
{% block script %}
  <script>
    let pause = [10, null];

    let wavesDefault = [
      [[4, "g", pause], "g"],
      [[7, "g", "g", pause], ["alert", "All enemy types have different health and speed stats."], "y", pause, "y"],
      [[5, "g"], [3, "y"]],
      [[20, "g"]],
      [[2, "y"], [5, [3, "g"], pause], [3, "y"]],
      [[10, "y"], [4, "o", pause], "o"],
      [[6, "g", "y", "o", pause], "g", "y", "o"],
      [[9, "y"], [7, "o"]],
      [[50, "g"]],
      [["alert", "<h1>New enemy ability: <b>Healing</b></h1>Enemies with this ability gradually regain health, so you need to destroy them quickly. They're also immune to poison."], [9, "oh", pause], "oh"],
      [[7, [6, "y", pause]], [6, "y"]],
      [[20, "oh"]],
      [[15, "o", "y"]],
      [[32, "g"], pause, [16, "y"], pause, [8, "o"], pause, [4, "r"]],
      [[6, "r"], ["alert", "<h1>New enemy ability: <b>Acceleration</b></h1>Enemies with this ability move faster as they lose health. They also can't be slowed by Slowing Towers."], [10, "oa"]],
      [[5, "g", [3, "r"], "g", pause], "g", [3, "r"], "g"],
      [[8, "oa", "ra", pause], "oa", "ra"],
      [[2, [12, "r"], pause], [12, "r"]],
      [[100, "y"]],
      [[2, "b", pause], "b"],
      [["alert", "<h1>New enemy ability: <b>Split</b></h1>Enemies with this ability split into two or more weaker enemies when they run out of health, making them much harder to destroy."], "rs"],
      [[7, "y", "o", "r", pause], [12, "rh"]],
      [[4, "os"], pause, [25, "o"], "bs"],
      [[5, "p"]],
      [[3, "pa", "bh", pause], [8, "rs", pause], "rs"],
      [["alert", "<h1>New enemy ability: <b>Blink</b></h1>Enemies with this ability switch between two states: visible and hidden. Without upgrades, towers can only hit them while they're visible."], [29, "yk", pause], "yk"],
      [[250, "g"]],
      [["alert", "Boss enemies have 100 HP."], "x"],
      ["pk"],
      [[5, "bs"]],
      [[2, [35, "r"], [5, "p"]]],
      [[14, "ba"], [26, "rh"]],
      [["alert", "<h1>New enemy ability: <b>Shield</b></h1>Enemies with this ability can only be damaged by explosions, poison, and hits from Long-Range Towers."], "gd"],
      [[30, "o"], pause, "x", pause, "x"],
      [[3, "bs"], [3, "ps"]],
      [[20, "rk"], pause, [5, "bk"]],
      [[3, "bd", pause], "bd"],
      ["xs"],
      [[10, "ok"], [8, "rh"], [19, "p"], [4, "rs"]],
      [[125, "yh"], "xa", [33, "b"]],
      [[4, "x"], [45, "r"], "xk"],
      [[7, "os"], pause, [13, "pk"] [64, "g"]],
      ["x", [18, "rd"], pause, "x"],
      [[85, "b", "p"]],
      [["alert", "Brown-boss enemies have 500 HP."], "z"],
      [[10, "x"], pause, [30, "bh"], [20, "r"]],
      [[3, "z", pause], [17, "ps"], [43, "ok"], [5, "x"]],
      [[15, "pk"], "xs", [3, "x", "z"], [300, "o"], "pd"],
      [[50, "ra"], [125, "bk"], pause, [67, "bh"], [999, "yk"], "z"],
      [[10, "g"], pause, [20, "y"], pause, [30, "o"], pause, [40, "r"], pause, [100, "p"], pause, [100, "b"], pause, [15, "x"], pause, [5, "z"]],

      //Hard mode only
      [[150, "bs"], [15, "bd"]],
      [[7, "x"], [80, "oa", "p"]],
      [[10, "za"]],
      [[100, "bk"], [12, "xh"], [75, "r", "pa", "os"]],
      [["alert", "Purple-boss enemies move much faster than normal bosses."], [4, "u", pause], "u"],
      [[30, "bd"], [3, "x"], pause, "xs"],
      [[150, "ra", "rh"]],
      [[3, "za"], pause, [2, "zh"], pause, "zk"],
      [[200, "ra"], "xd"],
      [[375, "p", "r", "b"], [20, "xa"]],
      [[6, "uh"], [15, "xa"]],
      [[50, "x"], pause, [10, "zh"]],
      [[8, "zk", pause], [20, "x"]],
      [[135, "bh", "rs"]],
      [[11, [17, "ra"], "z"]],
      [[14, "xa"], [15, [5, "od"], pause], [5, "z"], [5, "u"]],
      [[50, [2, "pa"], [5, "r"]], pause, [15, "za"]],
      [[5, "xd"]],
      [[60, "b"], [10, "uk"], [130, "b"]],
      ["uh", [10, [23, "rk"], "z"], [65, "ba"]],
      [[20, "u"], pause, [40, "xh"]],
      [[20, "pa"], [25, "pa", "xs"], pause, [200, "gd"], [3, "ua", "zh"]],
      [[111, "bh"], [8, "za"], [35, [9, "ph", "uk"]]],
      [[90, "b", "p"], pause, [100, "x"]],
      [[2, "zd", "ud", pause], "zd", "ud", [300, "ba"], [30, "xh"], pause, [20, "u", "uh", "ua"]]
    ];
  </script>
  <script src="{{ url_for('static', filename='js/tdMaps.js') }}"></script>
  <script>
    {
      let towerTypes = {
        basic: {
          name: "Basic Tower",
          color: "#ccc",
          description: "A cheap tower with average stats.",
          range: 2.5,
          speed: 1,
          strength: 1,
          price: 30,
          extra1: {
            description: "Projectiles can bounce to up to three nearby enemies.",
            price: 60,
            add: function() {
              this.bounce = 3;
            }
          },
          extra2: {
            description: "Projectiles can hit up to eight enemies.",
            price: 120,
            add: function() {
              this.bounce = 8;
            }
          },
          power: {
            description: "All Basic Towers attack 5Ã— as fast for 10 seconds.",
            price: 75,
            use: function() {
              towers.filter(tower => tower?.name == "Basic Tower").forEach(tower => tower.speedBoost = 250);
              sound.playSFX("powerUp2");
            }
          }
        },
        slowing: {
          name: "Slowing Tower",
          color: "#80ffff",
          description: "Weaker attacks, but hits slow down enemies for 10 seconds.",
          range: 1.64,
          speed: 1.92,
          strength: 0.5,
          slowing: true,
          price: 25,
          extra1: {
            description: "Enemies lose all abilities while they are slowed down.",
            price: 45,
            add: function() {
              this.abilityBlocking = true;
            }
          },
          extra2: {
            description: "Slowing affects enemies permanently.",
            price: 135,
            add: function() {
              this.permSlow = true;
            }
          },
          power: {
            description: "Stuns every onscreen enemy for 3 seconds. Stunned enemies take twice as much damage.",
            price: 60,
            use: function() {
              enemies.forEach(enemy => enemy.stunned = 75);
              sound.playSFX("powerUp2");
            }
          }
        },
        poison: {
          name: "Poison Tower",
          color: "#df80ff",
          description: "Enemies are poisoned when hit, taking 0.6 damage a second for 5 seconds.",
          range: 3.19,
          speed: 1.2,
          strength: 0.75,
          poison: true,
          price: 55,
          extra1: {
            description: "Poison can splash to a nearby enemy.",
            price: 30,
            add: function() {
              this.poisonSplash = true;
            }
          },
          extra2: {
            description: "Poisoned enemies take damage twice a second.",
            price: 40,
            add: function() {
              this.doublePoison = true;
            }
          },
          power: {
            description: "All onscreen enemies move backward for 3 seconds.",
            price: 55,
            use: function() {
              enemies.forEach(enemy => enemy.reverse = 75);
              sound.playSFX("powerUp2");
            }
          }
        },
        longRange: {
          name: "Long-Range Tower",
          color: "#ffdf40",
          description: "Infinite range and strong attacks, but fires slowly. Targets the strongest enemy onscreen.",
          range: Infinity,
          speed: 0.34,
          strength: 6,
          price: 80,
          extra1: {
            description: "Can hit blinking enemies while they are hidden.",
            price: 15,
            add: function() {
              this.seeInvisible = true;
            }
          },
          extra2: {
            description: "Enemies hit by this tower lose all abilities permanently.",
            price: 200,
            add: function() {
              this.removeAbilities = true;
            }
          },
          power: {
            description: "Does 150 damage to the strongest enemy on the screen.",
            price: 150,
            use: function() {
              let strongest = enemies.sort((a, b) => b.health - a.health)[0];
              strongest?.hit(Infinity, this);
              sound.playSFX("laser");
            }
          }
        },
        cannon: {
          name: "Cannon Tower",
          color: "#ff8f40",
          description: "Every hit creates an explosion that damages nearby enemies.",
          range: 3.4,
          speed: 0.66,
          strength: 2,
          price: 100,
          explosionSize: 100,
          extra1: {
            description: "Explosions are increased in size.",
            price: 30,
            add: function() {
              this.explosionSize = 150;
            }
          },
          extra2: {
            description: "Explosions do as much damage as direct hits.",
            price: 75,
            add: function() {
              this.powerfulExplosions = true;
            }
          },
          power: {
            description: "Creates a giant explosion at the center of the screen that does significant damage to all enemies inside of it.",
            price: 100,
            use: function() {
              //Create an explosion centered around the target enemy
              let inExplosion = enemies.filter(enemy => Math.sqrt((960 - enemy.x) ** 2 + (450 - enemy.y) ** 2) < 400);
              inExplosion.forEach(enemy => enemy.hit(25, this, "explosion")); //Do damage to every enemy inside the explosion
              //Draw the explosion as an orange circle
              ctx.strokeStyle = "transparent";
              ctx.fillStyle = "#ff8f4055";
              ctx.drawCircle(960, 450, 400);
              sound.playSFX("explode1");
            }
          }
        },
        money: {
          name: "Money Tower",
          color: "#80ff80",
          description: "Gets 3Ã— as much money from defeating enemies.",
          range: 3.32,
          speed: 0.88,
          strength: 1.25,
          extraMoney: true,
          price: 150,
          extra1: {
            description: "Adds an extra $10 every 10 seconds.",
            price: 300,
            add: function() {
              player.bonusMoney += 10;
            }
          },
          extra2: {
            description: "Adds an extra life every 15 seconds.",
            price: 250,
            add: function() {
              player.bonusLives += 1;
            }
          },
          power: {
            description: "Adds $100 to your total.",
            price: 380,
            use: function() {
              player.money += 100;
              sound.playSFX("coin1");
            }
          }
        },
        air: {
          name: "Air Tower",
          color: "#bfcfff",
          large: true,
          description: "Moves back and forth above the track. Has a large range and attacks quickly.",
          range: 3.61,
          speed: 2.79,
          strength: 1,
          movable: true,
          price: 150,
          extra1: {
            description: "Every fifth hit creates a small explosion.",
            price: 25,
            add: function() {
              this.nextExplosion = 5;
            }
          },
          extra2: {
            description: "Whatever tower is closest to the plane will get a range boost.",
            price: 50,
            add: function() {
              this.rangeBoosting = true;
            }
          },
          power: {
            description: "A highly powerful plane will fly over the track, starting from the exit.",
            price: 300,
            use: function() {
              let initialX = map.start[0] * 60;
              let initialY = map.start[1] * 60;
              mapArr.forEach(direction => {
                switch (direction) {
                  case "right":
                    initialX++;
                    break;
                  case "left":
                    initialX--;
                    break;
                  case "down":
                    initialY++;
                    break;
                  case "up":
                    initialY--;
                }
              });
              superPlane = {
                initialX: initialX,
                initialY: initialY,
                distance: 0,
                range: 3.97,
                speed: 12.57,
                strength: 3.5
              }
            }
          }
        },
        ultimate: {
          name: "Ultimate Tower",
          color: "#ff6860",
          large: true,
          description: "Can rapidly destroy many enemies across a wide range.",
          range: 4.65,
          speed: 7.38,
          strength: 2,
          price: 400,
          extra1: {
            description: "Attack power is slightly increased for each enemy on the screen.",
            price: 135,
            add: function() {
              this.crowdBonus = true;
            }
          },
          extra2: {
            description: "Does 2.5Ã— damage to boss enemies.",
            price: 1000,
            add: function() {
              this.bossBonus = true;
            }
          },
          power: {
            description: "All towers get double range, speed, and strength for 10 seconds.",
            price: 300,
            use: function() {
              towers.forEach(tower => {
                if (tower) tower.ultimateBoost = 250;
                sound.playSFX("powerUp2");
              });
            }
          }
        }
      };
      for (let type in towerTypes) {
        towerTypes[type].upgrades = {
          range: 0,
          speed: 0,
          strength: 0
        };

        //Create images for each tower type
        towerTypes[type].img = new Image();
        towerTypes[type].img.src = `../../static/img/towerdefense/${type}${type == "air" ? "-b" : ""}.png`;
        towerTypes[type].icon = new Image();
        towerTypes[type].icon.src = `../../static/img/towerdefense/${type}.png`;
        towerTypes[type].activeImg = new Image();
        towerTypes[type].activeImg.src = `../../static/img/towerdefense/${type}-active.png`;
      }

      let enemyTypes = {
        green: {
          speed: 1,
          health: 1
        },
        yellow: {
          speed: 1.5,
          health: 2
        },
        orange: {
          speed: 2,
          health: 3
        },
        red: {
          speed: 2.5,
          health: 4,
        },
        purple: {
          speed: 4,
          health: 2
        },
        brown: {
          speed: 1,
          health: 10
        },
        boss: {
          speed: 0.5,
          health: 100,
          boss: true
        },
        brownBoss: {
          speed: 0.25,
          health: 500,
          boss: true
        },
        purpleBoss: {
          speed: 4,
          health: 100,
          boss: true
        },
      };
      for (let type in enemyTypes) {
        enemyTypes[type].img = new Image();
        enemyTypes[type].img.src = `../../static/img/towerdefense/${type}.png`;
        if (type != "green" && type != "brownBoss" && type != "purpleBoss") {
          enemyTypes[type].imgSplit = new Image();
          enemyTypes[type].imgSplit.src = `../../static/img/towerdefense/${type}-split.png`;
        }
        if (enemyTypes[type].boss) {
          enemyTypes[type].imgRotated = new Image();
          enemyTypes[type].imgRotated.src = `../../static/img/towerdefense/${type}-r.png`;
          if (type == "boss") {
            enemyTypes[type].imgSplitRotated = new Image();
            enemyTypes[type].imgSplitRotated.src = `../../static/img/towerdefense/boss-split-r.png`;
          }
        }
      }

      class Tower {
        constructor(type, row, col) {
          for (let property in type) this[property] = type[property];
          //Make new objects so towers can be upgraded independently
          this.upgrades = Object.create(this.upgrades);
          this.extra1 = Object.create(this.extra1);
          this.extra2 = Object.create(this.extra2);
          this.value = type.price;
          //Convert the tower's position from squares to pixels
          this.x = col * 60 + 30;
          this.y = row * 60 + 30;
          if (type.name == "Air Tower") {
            //Make an array of all the squares the track goes through
            let trackSquares = [];
            grid.forEach((row, i) => row.forEach((square, j) => {
              if (square == "track") trackSquares.push([j, i]);
            }));
            //The plane will appear at the nearest track square to the tower
            let closest = trackSquares.sort((a, b) => ((col - a[0]) ** 2 + (row - a[1]) ** 2) - ((col - b[0]) ** 2 + (row - b[1]) ** 2))[0];
            this.planeStartX = map.start[0] * 60;
            this.planeStartY = map.start[1] * 60;
            switch (map.lines[0][0]) {
              case "right":
                this.planeStartX += 60;
                break;
              case "left":
                this.planeStartX -= 60;
                break;
              case "down":
                this.planeStartY += 60;
                break;
              case "up":
                this.planeStartY -= 60;
            }
            this.planeDistance = 0;
            let closestX = closest[0] * 60 + 30;
            let closestY = closest[1] * 60 + 30;
            let xPos = this.planeStartX;
            let yPos = this.planeStartY;
            //Increase the plane's distance on the track until it reaches the point closest to the tower
            for (let i = 0; xPos != closestX || yPos != closestY; i++) {
              switch (planePathArr[i]) {
                case "right":
                  xPos++;
                  break;
                case "left":
                  xPos--;
                  break;
                case "down":
                  yPos++;
                  break;
                case "up":
                  yPos--;
              }
              this.planeDistance++;
            }
          }
          this.i = towers.length;
          this.cooldown = 0; //Time until the tower can attack again
          //Display a menu with information and upgrade buttons
          this.showMenu = function() {
            if (paused) return;
            this.menuOpen = true;

            let menu = document.createElement("div");
            menu.classList.add("menu");
            menu.innerHTML = `
              <h1>${type.name}</h1>


              <h2><span id="sell" class="splitButton sellButton">
                <span class="buttonLeft">Sell</span><span class="buttonRight">+$${this.sellValue}</span>
              </span></h2>

              <h2>
                Range: ${Math.round(this.range * 100) / 100}
                <span id="range" class="splitButton">
                  <span class="buttonLeft">${(this.upgrades.range == 2 || this.range == Infinity) ? "Max" : "â†’&nbsp;" + Math.round(this.range * 1.25 * 100) / 100}</span><span class="buttonRight">$${this.upgradePrice("range")}</span>
                </span>
              </h2>

              <h2>
                Speed: ${Math.round(this.speed * 100) / 100}
                <span id="speed" class="splitButton">
                  <span class="buttonLeft">${(this.upgrades.speed == 2) ? "Max" : "â†’&nbsp;" + Math.round(this.speed * 1.5 * 100) / 100}</span><span class="buttonRight">$${this.upgradePrice("speed")}</span>
                </span>
              </h2>

              <h2>
                Strength: ${Math.round(this.strength * 100) / 100}
                <span id="strength" class="splitButton">
                  <span class="buttonLeft">${(this.upgrades.strength == 2) ? "Max" : "â†’&nbsp;" + Math.round(this.strength * 2 * 100) / 100}</span><span class="buttonRight">$${this.upgradePrice("strength")}</span>
                </span>
              </h2>

              <h2>
                Extra ${this.extra1.bought ? "2" : "1"}
                <span id="extra" class="splitButton">
                  <span class="buttonLeft">${this.extra2.bought ? "Bought" : "Add"}</span><span class="buttonRight">$${this.nextExtra.price}</span>
                </span>
              </h2>
              ${this.nextExtra.description ?? this.extra2.description}

              <h2>
                Special power
                <span id="power" class="splitButton">
                  <span class="buttonLeft">${difficulty == "hard" ? "Locked" : (this.power.bought ? "Bought" : "Unlock")}</span><span class="buttonRight">$${this.power.price}</span>
                </span>
              </h2>
              ${type.power.description}
            `;
            document.getElementById("container").append(menu);

            let sellButton = document.getElementById("sell");
            let rangeButton = document.getElementById("range");
            let speedButton = document.getElementById("speed");
            let strengthButton = document.getElementById("strength");
            let extraButton = document.getElementById("extra");
            let powerButton = document.getElementById("power");

            //Gray out upgrades that can't be bought
            if (player.money < this.upgradePrice("range") || this.range == Infinity) rangeButton.classList.add("unselectable");
            if (player.money < this.upgradePrice("speed")) speedButton.classList.add("unselectable");
            if (player.money < this.upgradePrice("strength")) strengthButton.classList.add("unselectable");
            if (player.money < this.nextExtra.price) extraButton.classList.add("unselectable");
            if (player.money < this.power.price || this.power.bought || difficulty == "hard") powerButton.classList.add("unselectable");

            if (this.upgrades.range == 2 || this.range == Infinity) rangeButton.classList.add("bought");
            if (this.upgrades.speed == 2) speedButton.classList.add("bought");
            if (this.upgrades.strength == 2) strengthButton.classList.add("bought");
            if (this.extra2.bought) extraButton.classList.add("bought");
            if (this.power.bought || difficulty == "hard") powerButton.classList.add("bought");

            //Center the menu horizontally
            menu.style.left = this.x / 1920 * 100 + "%";
            menu.style.transform = "translateX(-50%)";
            let menuRect = menu.getBoundingClientRect();
            let gameRect = document.getElementById("game").getBoundingClientRect();
            //If the menu is too far to the left or right, put it on the edge
            if (menuRect.x < gameRect.x) {
              menu.style.left = "0";
              menu.style.transform = "";
            } else if (menuRect.x + menuRect.width > gameRect.x + gameRect.width) {
              menu.style.left = "";
              menu.style.right = "0";
              menu.style.transform = "";
            }
            menu.style.bottom = 100 - (this.y / 1080 * 100) + 10 + "%";
            menuRect = menu.getBoundingClientRect(); //Get the menu position again
            //If the menu goes above the top of the game, put it below the tower
            if (menuRect.y < gameRect.y) {
              menu.style.bottom = "";
              menu.style.top = this.y / 1080 * 100 + 10 + "%";
            }

            //Remove the tower and give back 75% of all money spent on it
            sellButton.onclick = () => {
              towers[this.i] = null;
              player.money += this.sellValue;
              let row = Math.floor(this.y / 60);
              let col = Math.floor(this.x / 60);
              grid[row][col] = null; //Reset the grid square
              menu.remove();
              let squareEl = document.getElementById("r" + row + "c" + col);
              squareEl.classList.remove("tower");
              squareEl.onclick = null;
              this.menuOpen = false;
              //Remove bonuses
              if (this.name == "Money Tower") {
                if (this.extra1.bought) player.bonusMoney -= 0;
                if (this.extra2.bought) player.bonusLives -= 1;
              }
            };
            rangeButton.onclick = () => {
              if (this.upgrades.range < 2 && player.money >= this.upgradePrice("range") && this.range != Infinity) {
                player.money -= this.upgradePrice("range");
                this.value += this.upgradePrice("range");
                this.upgrades.range++;
                this.range *= 1.25;
                //Update the menu
                menu.remove();
                this.showMenu();
              }
            };
            speedButton.onclick = () => {
              if (this.upgrades.speed < 2 && player.money >= this.upgradePrice("speed")) {
                player.money -= this.upgradePrice("speed");
                this.value += this.upgradePrice("speed");
                this.upgrades.speed++;
                this.speed *= 1.5;
                //Update the menu
                menu.remove();
                this.showMenu();
              }
            };
            strengthButton.onclick = () => {
              if (this.upgrades.strength < 2 && player.money >= this.upgradePrice("strength")) {
                player.money -= this.upgradePrice("strength");
                this.value += this.upgradePrice("strength");
                this.upgrades.strength++;
                this.strength *= 2;
                //Update the menu
                menu.remove();
                this.showMenu();
              }
            };
            extraButton.onclick = () => {
              if (!this.extra2.bought && player.money >= this.nextExtra.price) {
                player.money -= this.nextExtra.price;
                this.value += this.nextExtra.price;
                this.nextExtra.add.bind(this)();
                this.nextExtra.bought = true;
                //Update the menu
                menu.remove();
                this.showMenu();
              }
            };
            powerButton.onclick = () => {
                if (!this.power.bought && player.money >= this.power.price && difficulty == "normal") {
                player.money -= this.power.price;
                this.value += this.power.price;
                this.power.bought = true;
                //Update the menu
                menu.remove();
                this.showMenu();
              }
            };

            this.closeMenu = () => {
              menu.remove();
              this.menuOpen = false;
            }
            document.getElementById("grid").onmousedown = this.closeMenu;
            document.addEventListener("keydown", e => {
              if (e.key == "Escape") this.closeMenu();
            });
          }
          this.upgradePrice = stat => {
            switch (this.upgrades[stat]) {
              case 2:
                return Infinity;
              case 1:
                return this.price * 3;
              default:
                return this.price;
            }
          }
        }

        get sellValue() {
          return Math.round(this.value * 0.75);
        }

        get nextExtra() {
          return this.extra2.bought ? {price: Infinity} : (this.extra1.bought ? this.extra2 : this.extra1);
        }
      }

      class Enemy {
        constructor(string) {
          //Set the enemy type based on the first letter
          switch (string[0]) {
            case "g":
              this.type = enemyTypes.green;
              break;
            case "y":
              this.type = enemyTypes.yellow;
              break;
            case "o":
              this.type = enemyTypes.orange;
              break;
            case "r":
              this.type = enemyTypes.red;
              break;
            case "p":
              this.type = enemyTypes.purple;
              break;
            case "b":
              this.type = enemyTypes.brown;
              break;
            case "x":
              this.type = enemyTypes.boss;
              break;
            case "z":
              this.type = enemyTypes.brownBoss;
              break;
            case "u":
              this.type = enemyTypes.purpleBoss;
          }
          this.speed = this.type.speed;
          this.health = this.type.health;
          //this.health = this.type.health * Math.ceil((currentWave + 1) / 10); //Increase enemies' HP every 10 rounds
          this.abilities = [];
          //Give the enemy an ability is there is a second character
          //Despite this.abilities being an array, an enemy can only have one ability in the current version of the game
          switch (string[1]) {
            case "h":
              this.abilities.push("healing");
              break;
            case "a":
              this.abilities.push("acceleration");
              break;
            case "s":
              this.abilities.push("split");
              break;
            case "k":
              this.abilities.push("blink");
              break;
            case "d":
              this.abilities.push("shield");
          }
          this.id = Math.random(); //Give the enemy a random ID so that no two enemy objects are identical
          this.distance = 0;
          if (this.abilities.includes("blink")) {
            this.visible = !!(blinkingCount % 2); //Every other blinking enemy will start off invisible
            if (Math.floor(frame / 100) % 2) this.visible = !this.visible; //Blinking enemies switch states every 100 frames
            blinkingCount++;
          } else {
            this.visible = true;
          }
          this.slowed = 0;
          this.poisoned = 0;
          this.hit = function(damage, tower, type) {
            if (this.stunned) damage *= 2;
            let shieldProtection = this.abilities.includes("shield") && !this.noAbilities && type != "explosion" && type != "poison" && tower?.name != "Long-Range Tower" //Only explosions, poison, and Long-Range Towers can damage shielded enemies
            if (!shieldProtection) this.health -= damage;

            if (this.health < 0.001) {
              let i = enemies.indexOf(this);
              player.money += (this.type.boss ? 10 : 1) * (tower?.extraMoney ? 3 : 1);
              if (this.abilities.includes("split")) {
                let type;
                if (this.type == enemyTypes.boss) {
                  let new1 = new Enemy("p");
                  let new2 = new Enemy("p");
                  let new3 = new Enemy("b");
                  let new4 = new Enemy("b");
                  new1.distance = this.distance;
                  new2.distance = this.distance - 20;
                  new3.distance = this.distance - 40;
                  new4.distance = this.distance - 60;
                  enemies.splice(i, 1, new1, new2, new3, new4);
                } else {
                  switch (this.type) {
                    case enemyTypes.yellow:
                      type = "g";
                      break;
                    case enemyTypes.orange:
                      type = "y";
                      break;
                    case enemyTypes.red:
                      type = "o";
                      break;
                    case enemyTypes.purple:
                    case enemyTypes.brown:
                      type = "r";
                  }
                  let new1 = new Enemy(type);
                  let new2 = new Enemy(type);
                  new1.distance = this.distance;
                  new2.distance = this.distance - 20;
                  enemies.splice(i, 1, new1, new2);
                }
              } else {
                enemies.splice(i, 1); //Remove the enemy
              }
            } else {
              if (this.abilities.includes("acceleration") && !this.noAbilities) this.speed = this.type.speed + this.type.speed * (1 - (this.health / this.type.health)) * 3; //Normal speed + (normal speed * portion of health lost * 3)
              if (tower?.removeAbilities) this.abilities = [];
            }
          }
        }
      }

      let grid = Array(15).fill().map(() => Array(32).fill(null)); //Array containing 15 arrays (rows), each containing 32 items (columns). Makes a deep copy of each array.

      //All images used in the game except towers & enemies
      let images = {
        buttons: {
          fullscreen: new Image(),
          exitFullscreen: new Image(),
          sound: new Image(),
          noSound: new Image(),
          showAlerts: new Image(),
          noAlerts: new Image(),
          pause: new Image(),
          play: new Image(),
          fastForward: new Image()
        },
        abilitySymbols: {
          healing: new Image(),
          shield: new Image(),
          acceleration: new Image()
        },
        planes: {
          left: new Image(),
          right: new Image(),
          up: new Image(),
          down: new Image(),
        },
        superPlanes: {
          left: new Image(),
          right: new Image(),
          up: new Image(),
          down: new Image(),
        }
      };
      for (let button in images.buttons) images.buttons[button].src = `../../static/img/towerdefense/${button}.png`;
      for (let symbol in images.abilitySymbols) images.abilitySymbols[symbol].src = `../../static/img/towerdefense/${symbol}.png`;
      for (let plane in images.planes) images.planes[plane].src = `../../static/img/towerdefense/air-${plane}.png`;
      for (let plane in images.superPlanes) images.superPlanes[plane].src = `../../static/img/towerdefense/superPlane-${plane}.png`;

      //Sound settings and list of sound effects
      let sound = {
        enabled: true,
        delay: 0.05, //How long each sound effect must play before it can start over
        sfx: {
          powerReady: new Audio("../../static/sound/td/td_power_ready.wav"),
          blip: new Audio("../../static/sound/td/td_blip01.wav"),
          coin1: new Audio("../../static/sound/td/td_coin01.wav"),
          coin2: new Audio("../../static/sound/td/td_coin02.wav"),
          explode1: new Audio("../../static/sound/td/td_explode01.wav"),
          explode2: new Audio("../../static/sound/td/td_explode02.wav"),
          explode3: new Audio("../../static/sound/td/td_explode03.wav"),
          laser: new Audio("../../static/sound/td/td_laser01.wav"),
          powerUp1: new Audio("../../static/sound/td/td_powerup01.wav"),
          powerUp2: new Audio("../../static/sound/td/td_powerup02.wav"),
          shoot: new Audio("../../static/sound/td/td_shoot02.wav"),
          success: new Audio("../../static/sound/td/td_success01.wav"),
          basicHit: new Audio("../../static/sound/td/td_hit01.wav"),
          slowingHit: new Audio("../../static/sound/td/td_slow_hit.wav"),
          poisonHit: new Audio("../../static/sound/td/td_poison_hit.wav"),
          moneyHit: new Audio("../../static/sound/td/td_money_hit.wav"),
          planeHit: new Audio("../../static/sound/td/td_plane_hit.wav"),
          ultimateHit: new Audio("../../static/sound/td/td_ultimate_hit.wav"),
          longRangeHit: new Audio("../../static/sound/td/td_longrange_hit.wav")
        },
        playSFX: function(name) {
          if (this.enabled) {
            let delay = this.sfx[name].delay || this.delay;
            if (this.sfx[name].currentTime >= delay) this.sfx[name].currentTime = 0;
            this.sfx[name].play();
          }
        }
      };
      //Turn down the volume of each of the sound effects
      for (const effect in sound.sfx) {
          sound.sfx[effect].volume = 0.2;
      }
      //Manually adjust some sound effects
      sound.sfx.ultimateHit.delay = sound.delay / 2;
      sound.sfx.blip.volume = 0.5;
      sound.sfx.slowingHit.volume = 0.1;
      sound.sfx.longRangeHit.volume = 0.15;
      sound.sfx.planeHit.volume = 0.15;
      sound.sfx.ultimateHit.volume = 0.4;
      sound.sfx.shoot.volume = 0.6;
      for (let type in towerTypes) towerTypes[type].hitSound = type + "Hit"; //Give all towers except for Cannon Towers different hit sounds
      towerTypes.air.hitSound = "planeHit";

      let canvas = document.getElementById("game");
      let ctx = canvas.getContext("2d");

      ctx.drawCircle = function(x, y, r) {
        this.beginPath();
        this.arc(x, y, r, 0, 2 * Math.PI);
        this.stroke();
        this.fill();
      }

      ctx.drawPath = function(instructions) {
        this.lineWidth = 1.5;
        this.strokeStyle = "#80ffff";
        this.beginPath();
        let xPos = instructions.start[0] * 60;
        let yPos = instructions.start[1] * 60;
        let col = instructions.start[0] - 0.5;
        let row = instructions.start[1] - 0.5;
        instructions.lines.forEach(line => {
          this.moveTo(xPos, yPos);
          for (let i = 0; i < line[1]; i++) {
            switch (line[0]) {
              case "right":
                xPos += 60;
                col++;
                break;
              case "left":
                xPos -= 60;
                col--;
                break;
              case "down":
                yPos += 60;
                row++;
                break;
              case "up":
                yPos -= 60;
                row--;
            }
            this.lineTo(xPos, yPos);
            if (grid[row] && grid[row][col] === null) grid[row][col] = "track"; //Change the value of every square the path goes through
          }
        });
        this.stroke();
      }

      ctx.drawPreview = function(instructions) {
        this.lineWidth = 1.5;
        this.strokeStyle = "#80ffff";
        this.beginPath();
        let xPos = instructions.start[0] * 30 + 480;
        let yPos = instructions.start[1] * 30 + 120;
        instructions.lines.forEach(line => {
          let startX = xPos;
          let startY = yPos;
          if (startX < 480) startX = 480;
          if (startX > 1440) startX = 1440;
          if (startY < 120) startY = 120;
          if (startY > 570) startY = 570;
          this.moveTo(startX, startY);
          for (let i = 0; i < line[1]; i++) {
            switch (line[0]) {
              case "right":
                xPos += 30;
                break;
              case "left":
                xPos -= 30;
                break;
              case "down":
                yPos += 30;
                break;
              case "up":
                yPos -= 30;
            }
            let endX = xPos;
            let endY = yPos;
            if (endX < 480) endX = 480;
            if (endX > 1440) endX = 1440;
            if (endY < 120) endY = 120;
            if (endY > 570) endY = 570;
            this.lineTo(endX, endY);
          }
        });
        this.stroke();
      }

      function update() {
        ctx.clearRect(0, 0, 1920, 1080); //Clear the canvas
        ctx.drawPath(map);

        //Buttons in the top-left corner

        //Fullscreen button
        ctx.drawImage(document.fullscreenElement ? images.buttons.exitFullscreen : images.buttons.fullscreen, 15, 15, 30, 30);
        document.getElementById("r0c0").classList.add("gameButton");
        document.getElementById("r0c0").onclick = () => {
          if (!paused) {
            if (document.fullscreenElement) document.exitFullscreen();
            else document.documentElement.requestFullscreen();
          } else {
            //Resume button
            paused = false;
            animate = setInterval(update, fastForward ? 10 : 40);
            document.getElementById("towers").classList.remove("hidden");
            if (document.getElementById("alert")) hideAlert(); //If there is an alert, hide it
          }
        };
        //Sound button
        ctx.drawImage(sound.enabled ? images.buttons.sound : images.buttons.noSound, 75, 15, 30, 30);
        document.getElementById("r0c1").classList.add("gameButton");
        document.getElementById("r0c1").onclick = () => {
          if (!paused) sound.enabled = !sound.enabled
        };
        //Alerts button
        ctx.drawImage(noAlerts ? images.buttons.noAlerts : images.buttons.showAlerts, 135, 15, 30, 30);
        document.getElementById("r0c2").classList.add("gameButton");
        document.getElementById("r0c2").onclick = () => {
          if (!paused) {
            if (noAlerts === undefined) gameAlert("No more alerts will be shown.");
            noAlerts = !noAlerts;
          }
        };
        //Pause button
        ctx.drawImage(images.buttons.pause, 195, 15, 30, 30);
        document.getElementById("r0c3").classList.add("gameButton");
        document.getElementById("r0c3").onclick = () => {
          if (!paused) {
            paused = true;
            clearInterval(animate);
            document.getElementById("towers").classList.add("hidden");
            for (let i = 1; i < 5; i++) document.getElementById("r0c" + i).classList.remove("gameButton");
            //Prevent placing towers while paused
            grid.forEach((row, i) => row.forEach((square, j) => {
              let squareEl = document.getElementById("r" + i + "c" + j);
              if (squareEl.ondragleave) squareEl.ondragleave();
            }));
            for (let tower in towerTypes) if (towerTypes[tower].dragging) document.getElementById(tower).ondragend();
            //If a tower's menu is open, close it
            let menuTower = towers.find(tower => tower?.menuOpen);
            menuTower?.closeMenu();
            ctx.clearRect(0, 0, 300, 60);
            ctx.drawImage(fastForward ? images.buttons.fastForward : images.buttons.play, 15, 15, 30, 30);
          }
        };
        //Fast forward button (normal mode only)
        if (difficulty == "normal") {
          ctx.drawImage(fastForward ? images.buttons.play : images.buttons.fastForward, 255, 15, 30, 30);
          document.getElementById("r0c4").classList.add("gameButton");
          document.getElementById("r0c4").onclick = () => {
            if (!paused) {
              fastForward = !fastForward;
              clearInterval(animate);
              animate = setInterval(update, fastForward ? 10 : 40); //If fast forward is turned on, play at 4x the normal speed
            }
          };
        }

        if (dragOver && dragOver[0].name != "Air Tower") {
          ctx.lineWidth = 1;
          ctx.strokeStyle = "white";
          ctx.fillStyle = "#aaa5";
          ctx.drawCircle(dragOver[1] * 60 + 30, dragOver[2] * 60 + 30, dragOver[0].range * 60);
        }

        //Spawn enemies
        if (!(frame % 4)) { //Do this every 4 frames
          let next = map.waves[currentWave][currentEnemy];
          while (Array.isArray(next)) {
            if (next[0] == "alert") {
              if (!noAlerts) gameAlert(next[1]);
              map.waves[currentWave].splice(currentEnemy, 1); //Remove the array
            } else {
              let repeat = next[0]; //The array's first item is the number of times to repeat
              let items = next.slice(1); //Everything that follows is repeated
              let repeated = Array(repeat).fill(items).flat(); //Make an array containing the items array repeated, then flatten it
              map.waves[currentWave].splice(currentEnemy, 1, ...repeated); //Add each item in repeated to the wave and remove the array
            }
            next = map.waves[currentWave][currentEnemy];
          }
          //Add next enemy
          if (next) {
            let newEnemy = new Enemy(next);
            enemies.push(newEnemy);
          }

          if (map.waves[currentWave][currentEnemy + 1] !== undefined) { //If there are enemies left in the wave
            currentEnemy++;
          } else {
            if (!map.waves[currentWave + 1]) { //If there are no waves left
              //Once all enemies are defeated, end the game
              if (enemies.length) {
                map.waves[currentWave].push(null);
              } else {
                endGame(true);
                return;
              }
            } else {
              currentWave++;
              currentEnemy = 0;
            }
            //if (currentWave == 50) for (let type in enemyTypes) enemyTypes[type].health *= 2; //All enemy types get double health for the last 25 rounds of hard mode
          }
        }

        enemies.forEach((enemy, i) => {
          //If the enemy is at the end of the track, subtract a life and remove it from the array
          //Otherwise, draw it in its new position
          if (enemy.distance >= mapArr.length) {
            player.lives -= enemy.type.health;
            if (player.lives) sound.playSFX("blip");
            gameAchievements[0] = 0;
            enemies.splice(i, 1);
          } else {
            if (enemy.reverse) {
              enemy.distance -= enemy.speed * (enemy.slowed ? 2 : 4);
              enemy.reverse--;
            } else if (enemy.stunned) {
              enemy.stunned--;
            } else {
              enemy.distance += enemy.speed * (enemy.slowed ? 2 : 4);
            }
            if (enemy.slowed) enemy.slowed--;
            if (enemy.poisoned && --enemy.poisoned % (enemy.doublePoisoned ? 12.5 : 25) < 1) enemy.hit(0.6, null, "poison");
            if (!enemy.poisoned) delete enemy.doublePoisoned;

            enemy.x = map.start[0] * 60;
            enemy.y = map.start[1] * 60;
            let img = enemy.type.img;
            for (let j = 0; j < Math.round(enemy.distance); j++) {
              //Move the enemy forward
              switch (mapArr[j]) {
                case "right":
                  enemy.x++;
                  break;
                case "left":
                  enemy.x--;
                  break;
                case "down":
                  enemy.y++;
                  break;
                case "up":
                  enemy.y--;
              }
              if (enemy.abilities.includes("split")) {
                img = (enemy.type.boss && (mapArr[j] == "right" || mapArr[j] == "left")) ? enemy.type.imgSplitRotated : enemy.type.imgSplit; //If the enemy is a boss and moving horizontally, rotate it
              } else if (enemy.type.boss && (mapArr[j] == "right" || mapArr[j] == "left")) {
                img = enemy.type.imgRotated;
              } else {
                img = enemy.type.img;
              }
            }
            if (!enemy.visible) ctx.globalAlpha = 0.25; //If the enemy is hidden, make it semitransparent
            ctx.drawImage(img, enemy.x - 40, enemy.y - 40);
            ctx.globalAlpha = 1;
            //Draw ability symbols inside the enemy
            if (enemy.abilities.includes("healing") && !enemy.noAbilities) ctx.drawImage(images.abilitySymbols.healing, enemy.x - 40, enemy.y - 40);
            if (enemy.abilities.includes("shield") && !enemy.noAbilities) ctx.drawImage(images.abilitySymbols.shield, enemy.x - 40, enemy.y - 40);
            if (enemy.abilities.includes("acceleration") && !enemy.noAbilities) ctx.drawImage(images.abilitySymbols.acceleration, enemy.x - 40, enemy.y - 40);
          }

          if (enemy.abilities.includes("healing") && enemy.health < enemy.type.health && !enemy.noAbilities) {
            enemy.health += 1 / 75;
            if (enemy.health > enemy.type.health) enemy.health = enemy.type.health; //Don't let the enemy's health go above the initial value
          }
          if (enemy.abilities.includes("blink")) {
            if (!(frame % 100)) enemy.visible = !enemy.visible;
          } else {
            enemy.visible = true;
          }
          if (enemy.noAbilities) enemy.visible = true;

          if (enemy.noAbilities) enemy.noAbilities--;
        });

        towers.forEach(tower => {
          if (!tower) return; //If the tower has been sold, skip this
          ctx.drawImage(tower.img, tower.x - 30, tower.y - 30);

          if (tower.name == "Air Tower") {
            tower.planeDistance += 8;
            tower.planeX = tower.planeStartX;
            tower.planeY = tower.planeStartY;
            let img;
            for (let i = 0; i < Math.round(tower.planeDistance); i++) {
              let j = i;
              while (j >= planePathArr.length) j -= planePathArr.length;
              switch (planePathArr[j]) {
                case "right":
                  tower.planeX++;
                  break;
                case "left":
                  tower.planeX--;
                  break;
                case "down":
                  tower.planeY++;
                  break;
                case "up":
                  tower.planeY--;
              }
              img = images.planes[planePathArr[j]];
            }
            ctx.drawImage(img, tower.planeX - 30, tower.planeY - 30);
          }

          if (tower.menuOpen) {
            //Show the tower's range
            ctx.lineWidth = 1;
            ctx.strokeStyle = "white";
            ctx.fillStyle = "#aaa5";
            let x = (tower.name == "Air Tower") ? tower.planeX : tower.x;
            let y = (tower.name == "Air Tower") ? tower.planeY : tower.y;
            let range = tower.range;
            if (towers.find(owned => owned?.rangeBoosted == tower)) range *= 1.25;
            if (tower.ultimateBoost) range *= 2;
            ctx.drawCircle(x, y, range * 60);
          }

          if (tower.rangeBoosting) {
            let otherTowers = towers.filter(owned => owned && owned != tower && owned.range != Infinity); //Remove this tower, sold towers, and Long-Range Towers
            let closest = otherTowers.sort((a, b) => ((tower.planeX - a.x) ** 2 + (tower.planeY - a.y) ** 2) - ((tower.planeX - b.x) ** 2 + (tower.planeY - b.y) ** 2))[0];
            tower.rangeBoosted = closest;
          }

          if (tower.cooldown > 1) {
            let reduceCooldown = 1;
            if (tower.speedBoost) reduceCooldown *= 5;
            if (tower.ultimateBoost) reduceCooldown *= 2;
            tower.cooldown -= reduceCooldown;
          } else {
            let x = (tower.name == "Air Tower") ? tower.planeX : tower.x;
            let y = (tower.name == "Air Tower") ? tower.planeY : tower.y;
            let range = tower.range;
            if (towers.find(owned => owned?.rangeBoosted == tower)) range *= 1.25; //Range boost from Air Tower
            if (tower.ultimateBoost) range *= 2;
            let inRange = enemies.filter(enemy => Math.sqrt((x - enemy.x) ** 2 + (y - enemy.y) ** 2) < range * 60); //Use the Pythagorean Theorem to determine if each enemy is inside the tower's range
            if (!tower.seeInvisible) inRange = inRange.filter(enemy => enemy.visible);
            if (inRange.length) {
              let furthest = inRange.sort((a, b) => b.distance - a.distance)[0]; //Sort inRange from highest to lowest distance and get the first item
              let strong = inRange.sort((a, b) => b.health - a.health); //Sort inRange from highest to lowest health
              let strongest = strong.find(enemy => enemy.abilities.includes("shield")) || strong[0]; //Target shielded enemies
              let target = (tower.name == "Long-Range Tower") ? strongest : furthest;
              let damage = tower.strength;
              if (tower.crowdBonus) damage *= 1 + enemies.length / 100; //Increase the damage by 1% for each enemy onscreen
              console.log(target)
              if (tower.bossBonus && target.type.boss) damage *= 2.5;
              if (tower.ultimateBoost) damage *= 2;
              target.hit(damage, tower);

              if (sound.sfx[tower.hitSound]) sound.playSFX(tower.hitSound, tower.name); //Play hit sound

              if (tower.slowing && !target.abilities.includes("acceleration")) target.slowed = tower.permSlow ? Infinity : 250;
              if (tower.abilityBlocking && !target.abilities.includes("acceleration")) target.noAbilities = tower.permSlow ? Infinity : 250;
              if (tower.poison && !target.abilities.includes("healing")) {
                target.poisoned = 125; //Poison the target for 125 frames
                if (tower.doublePoison) target.doublePoisoned = true;
              }
              if (tower.bounce) {
                let bouncePath = [target]; //Make an array of all enemies hit so they aren't bounced to again
                let close = enemies.filter(enemy => Math.sqrt((target.x - enemy.x) ** 2 + (target.y - enemy.y) ** 2) < 100 && !bouncePath.includes(enemy) && enemy.visible);
                let bouncesLeft = tower.bounce;
                while (close.length && bouncesLeft) { //While the projectile can still bounce and there are enemies to bounce to
                  let closest = close.sort((a, b) => ((target.x - a.x) ** 2 + (target.y - a.y) ** 2) - ((target.x - b.x) ** 2 + (target.y - b.y) ** 2))[0];
                  let distance = Math.sqrt((target.x - closest.x) ** 2 + (target.y - closest.y) ** 2);
                  let oldTarget = target;
                  target = closest;

                  ctx.lineWidth = 4;
                  ctx.strokeStyle = tower.color;
                  ctx.beginPath();
                  ctx.moveTo(oldTarget.x, oldTarget.y);
                  ctx.lineTo(target.x, target.y);
                  ctx.stroke();

                  damage = tower.strength;
                  if (tower.ultimateBoost) damage *= 2;
                  target.hit(damage, tower);
                  bouncePath.push(target);
                  close = enemies.filter(enemy => Math.sqrt((target.x - enemy.x) ** 2 + (target.y - enemy.y) ** 2) < 100 && !bouncePath.includes(enemy) && enemy.visible);
                  bouncesLeft--;
                }
              }
              if (tower.poisonSplash) {
                let close = enemies.filter(enemy => Math.sqrt((target.x - enemy.x) ** 2 + (target.y - enemy.y) ** 2) < 100 && enemy != target && enemy.visible);
                if (close.length) {
                  let closest = close.sort((a, b) => ((target.x - a.x) ** 2 + (target.y - a.y) ** 2) - ((target.x - b.x) ** 2 + (target.y - b.y) ** 2))[0];
                  let distance = Math.sqrt((target.x - closest.x) ** 2 + (target.y - closest.y) ** 2);
                  target = closest;
                  target.poisoned = 125;
                  if (tower.doublePoison) target.doublePoisoned = true;
                }
              }
              if (tower.nextExplosion === 0) tower.explosionSize = 75;
              if (tower.explosionSize) { //If the hit causes an explosion
                //Create an explosion centered around the target enemy
                let inExplosion = enemies.filter(enemy => Math.sqrt((target.x - enemy.x) ** 2 + (target.y - enemy.y) ** 2) < tower.explosionSize);
                let explosionDamage = tower.powerfulExplosions ? tower.strength : 1;
                inExplosion.forEach(enemy => enemy.hit(explosionDamage, tower, "explosion")); //Do damage to every enemy inside the explosion
                //Draw the explosion as an orange circle
                ctx.strokeStyle = "transparent";
                ctx.fillStyle = "#ff8f4055";
                ctx.drawCircle(target.x, target.y, tower.explosionSize);
                sound.playSFX("explode1");
              }
              if (tower.nextExplosion) {
                tower.nextExplosion--;
              } else if (tower.nextExplosion === 0) {
                delete tower.explosionSize;
                tower.nextExplosion = 5;
              }

              ctx.drawImage(tower.activeImg, tower.x - 30, tower.y - 30); //Light up the firing tower for 1 frame

              //Draw line of fire
              ctx.lineWidth = 4;
              ctx.strokeStyle = tower.color;
              ctx.beginPath(); //Start a new path
              if (tower.name == "Air Tower") ctx.moveTo(tower.planeX, tower.planeY);
              else ctx.moveTo(tower.x, tower.y);
              ctx.lineTo(target.x, target.y);
              ctx.stroke(); //Render the path

              tower.cooldown += 25 / tower.speed;
            }
          }

          if (tower.speedBoost) tower.speedBoost--;
          if (tower.ultimateBoost) tower.ultimateBoost--;

          if (tower.upgrades.range == 2 && tower.upgrades.speed == 2 && tower.upgrades.strength == 2 && tower.extra2.bought) gameAchievements[2] = 1;
        });

        if (superPlane) {
          superPlane.distance += 12;
          if (superPlane.distance > superPlanePathArr.length) {
            superPlane = null;
          } else {
            superPlane.x = superPlane.initialX;
            superPlane.y = superPlane.initialY;
            let img;
            for (let i = 0; i < Math.round(superPlane.distance); i++) {
              switch (superPlanePathArr[i]) {
                case "right":
                  superPlane.x++;
                  break;
                case "left":
                  superPlane.x--;
                  break;
                case "down":
                  superPlane.y++;
                  break;
                case "up":
                  superPlane.y--;
              }
              img = images.superPlanes[superPlanePathArr[i]];
            }
            ctx.drawImage(img, superPlane.x - 45, superPlane.y - 45);

            if (superPlane.cooldown > 1) {
              superPlane.cooldown --;
            } else {
              let inRange = enemies.filter(enemy => Math.sqrt((superPlane.x - enemy.x) ** 2 + (superPlane.y - enemy.y) ** 2) < superPlane.range * 60 && enemy.visible);
              if (inRange.length) {
                let target = inRange.sort((a, b) => b.distance - a.distance)[0];
                target.hit(superPlane.strength);
                sound.playSFX("planeHit");
                ctx.lineWidth = 4;
                ctx.strokeStyle = "#ff6860";
                ctx.beginPath();
                ctx.moveTo(superPlane.x, superPlane.y);
                ctx.lineTo(target.x, target.y);
                ctx.stroke();

                superPlane.cooldown += 25 / superPlane.speed;
              }
            }
          }
        }

        for (let tower in towerTypes) {
          let towerEl = document.getElementById(tower);

          if (towerTypes[tower].power.cooldown) {
            towerTypes[tower].power.cooldown--;
            if (!towerTypes[tower].power.cooldown) {
              let powerEl = document.getElementById(tower + "Power");
              powerEl.classList.add("powerReady");
              setTimeout(() => powerEl.classList.remove("powerReady"), 1000);
              sound.playSFX("powerReady");
            }
          }

          if (player.money >= towerTypes[tower].price) {
            towerEl.classList.remove("unselectable");
            towerEl.draggable = true;
            //Do this when the tower is picked up
            towerEl.ondragstart = () => {
              towerTypes[tower].dragging = true;
              document.getElementById("grid").classList.add("visibleLines"); //Show the grid's lines
              grid.forEach((row, i) => row.forEach((square, j) => {
                let squareEl = document.getElementById("r" + i + "c" + j);
                if (square) { //If the square is not null
                  squareEl.ondragover = () => squareEl.classList.add("undroppable");
                  squareEl.ondragleave = () => squareEl.classList.remove("undroppable");
                  squareEl.ondrop = () => squareEl.classList.remove("undroppable");
                } else {
                  squareEl.ondragover = () => {
                    event.preventDefault();
                    squareEl.classList.add("droppable");
                    dragOver = [towerTypes[tower], j, i]; //Save the tower being sragges, the column, and the row
                  };
                  squareEl.ondragleave = () => {
                    squareEl.classList.remove("droppable");
                    dragOver = null;
                  };
                  squareEl.ondrop = () => {
                    squareEl.classList.remove("droppable");
                    dragOver = null;
                    document.getElementById("grid").classList.remove("visibleLines");
                    if (player.money >= towerTypes[tower].price) { //Check that the player can afford the tower again to prevent cheating
                      //Place the tower
                      player.money -= towerTypes[tower].price;
                      let newTower = new Tower(towerTypes[tower], i, j);
                      towers.push(newTower);
                      grid[i][j] = newTower;
                      let squareEl = document.getElementById("r" + i + "c" + j);
                      squareEl.classList.add("tower");
                      squareEl.onclick = () => newTower.showMenu();
                      towerTypes[tower].placed = true;
                      if (Object.values(towerTypes).every(tower => tower.placed)) gameAchievements[1] = 1;
                      if (newTower.name == "Ultimate Tower") gameAchievements[4] = 0;
                      if (newTower.name == "Basic Tower") gameAchievements[5] = 0;
                      if (towers.length == 4) gameAchievements[6] = 0;
                    }
                  };
                }
              }));
            };
            towerEl.ondragend = () => {
              delete towerTypes[tower].dragging;
              dragOver = null;
              document.getElementById("grid").classList.remove("visibleLines");
              grid.forEach((row, i) => row.forEach((square, j) => {
                let squareEl = document.getElementById("r" + i + "c" + j);
                squareEl.ondragover = null;
                squareEl.ondragleave = null;
                squareEl.ondrop = null;
              }));
            };
          } else {
            towerEl.classList.add("unselectable");
            towerEl.draggable = false;
          }

          let power = towerTypes[tower].power;
          let powerButton = document.getElementById(tower + "Power");
          if (power.bought && towers.find(owned => owned?.name == towerTypes[tower].name)) {
            powerButton.classList.remove("invisible");
            if (power.cooldown) {
              powerButton.classList.add("unselectable");
              let percent = power.cooldown / 3000 * 100;
              powerButton.style.background = `linear-gradient(to left, var(--emphasis-color), var(--emphasis-color) ${percent}%, gray ${percent}%)`; //Show how long until the power can be used again
            } else {
              powerButton.style.background = null; //Reset the background
              powerButton.classList.remove("unselectable");
            }
          } else {
            powerButton.classList.add("invisible");
          }
        }

        if (!(frame % 250)) player.money += player.bonusMoney;
        if (!(frame % 375)) player.lives += player.bonusLives;

        let menuTower = towers.find(tower => tower?.menuOpen);
        if (menuTower) {
          if (player.money >= menuTower.upgradePrice("range") && menuTower.range !== Infinity) document.getElementById("range").classList.remove("unselectable");
          if (player.money >= menuTower.upgradePrice("speed")) document.getElementById("speed").classList.remove("unselectable");
          if (player.money >= menuTower.upgradePrice("strength")) document.getElementById("strength").classList.remove("unselectable");
          if (player.money >= menuTower.nextExtra.price) document.getElementById("extra").classList.remove("unselectable");
          if (player.money >= menuTower.power.price && !menuTower.power.bought && difficulty == "normal") document.getElementById("power").classList.remove("unselectable");
        }

        //Update text in top-right
        ctx.font = "30px monospace";
        ctx.textAlign = "left";
        if (player.lives > 0) {
          //Display time, money, and lives in the top-right corner
          ctx.fillStyle = "#ddd";
          ctx.fillText(`${(currentWave + 1).toString().padStart(2, "0")}/${map.waves.length}`, 1564, 40); //Show current and total waves
          ctx.fillStyle = "#80ff80";
          ctx.fillText("$" + player.money.toString().padStart(5, "0"), 1684, 40);
          ctx.fillStyle = "#ff6860";
          ctx.fillText("â¤ï¸Ž" + player.lives.toString().padStart(3, "0"), 1820, 40);
        } else {
          endGame();
        }

        frame++;
      }

      let progress = "{{ progress }}"; //2 means map completed on hard, 1 means map completed on normal, 0 means map not completed
      let achievements = "{{ achievements }}" || "0000000"; //1 means earned, 0 means not earned
      achievements = achievements.split("");
      let player = {
        money: 75000,
        lives: 100,
        bonusMoney: 0,
        bonusLives: 0
      };
      let mapIndex = 0;
      let map;
      let mapArr;
      let planePathArr;
      let superPlanePathArr;
      let difficulty = "normal";
      let gameAchievements = [1, 0, 0, 0, 1, 1, 1];
      let enemies = [];
      let blinkingCount = 0; //Keep track of blinking enemies to alternate between visible and invisible
      let towers = [];
      let frame = 0;
      let currentWave = 0;
      let currentEnemy = 0;
      let superPlane;
      let noAlerts;
      let paused;
      let fastForward;
      let dragOver;
      let animate;

      progress = progress.padEnd(maps.length, "0"); //Add zeroes to the end when maps are added
      if (progress.length > maps.length) progress = progress.slice(0, maps.length - progress.length); //Remove numbers from the end if maps are deleted
      request.open("POST", "/updateuser?field=tdProgress&value=" + progress);
      request.send();
      progress = progress.split(""); //Turn the string into an array

      let achievementList = [
        "Complete a game without losing any lives",
        "Purchase every tower type in one game",
        "Fully upgrade a tower",
        "Use every special power in one game",
        "Win a game without any Ultimate Towers",
        "Win a game without any Basic Towers",
        "Win a game without placing more than three towers"
      ];

      //Create the title
      ctx.drawPreview({
        start: [1, 3],
        lines: [
          ["right", 1],
          ["up", 1],
          ["down", 1],
          ["right", 1],
          ["left", 1],
          ["down", 3],
          ["right", 2],
          ["up", 2],
          ["right", 2],
          ["down", 2],
          ["left", 2],
          ["up", 2],
          ["right", 3],
          ["down", 2],
          ["right", 1],
          ["up", 1],
          ["down", 1],
          ["right", 1],
          ["up", 2],
          ["right", 1],
          ["down", 1],
          ["right", 1],
          ["up", 1],
          ["left", 1],
          ["down", 2],
          ["right", 2],
          ["up", 2],
          ["right", 1],
          ["down", 1],
        ]
      });
      ctx.drawPreview({
        start: [17, 2],
        lines: [
          ["down", 4],
          ["left", 2],
          ["up", 2],
          ["right", 3],
          ["down", 1],
          ["right", 1],
          ["up", 1],
          ["left", 1],
          ["down", 2],
          ["right", 2],
          ["up", 4],
          ["right", 1],
          ["down", 1],
          ["up", 1],
          ["left", 1],
          ["down", 2],
          ["right", 2],
          ["down", 1],
          ["right", 1],
          ["up", 1],
          ["left", 1],
          ["down", 2],
          ["right", 2],
          ["up", 2],
          ["right", 2],
          ["down", 2],
          ["right", 2],
          ["up", 1],
          ["left", 1],
          ["up", 1],
          ["right", 2],
          ["down", 1],
          ["right", 1],
          ["up", 1],
          ["left", 1],
          ["down", 2],
          ["right", 2]
        ]
      });
      ctx.fillStyle = "white";
      ctx.textAlign = "center";
      ctx.font = "48px Segoe UI";
      ctx.fillText("Click to continue", 960, 600);
      ctx.font = "32px Segoe UI";
      ctx.fillText("Created by Oley Birkeland", 960, 1000);
      let completeMaps = progress.reduce((a, b) => +a + +b); //Convert every character to a number and add
      let totalMaps = progress.length * 2;
      let completeAchv = achievements.reduce((a, b) => +a + +b);
      let totalAchv = achievementList.length;
      let progressEl = document.getElementById("progress");
      if (completeMaps == totalMaps && completeAchv == totalAchv) progressEl.classList.add("complete");
      let progressText = document.createElement("span");
      progressText.id = "progressText";
      progressText.innerText = `${completeMaps}/${totalMaps} complete`;
      progressEl.append(progressText);
      let achvText = document.createElement("div");
      achvText.id = "achievements";
      achvText.innerHTML = `<span>${completeAchv}/${totalAchv} achievements</span>`;
      let achvButton = document.createElement("button");
      achvButton.id = "achvButton";;
      achvButton.innerText = "Open list";
      achvButton.onclick = () => {
        let listText = "<ul>";
        achievementList.forEach((achievement, i) => {
          let earned = +achievements[i];
          let tag = earned ? "s" : "b";
          listText += `<li class=${earned ? "earned" : ""}><${tag}>${achievement}</${tag}></li>`;
        });
        listText += "</ul>";
        gameAlert(listText, true);
      }
      achvText.append(achvButton);
      progressEl.append(achvText);

      function showMaps() {
        document.getElementById("progress").classList.add("hidden");
        if (document.getElementById("alert")) hideAlert();
        ctx.clearRect(0, 0, 1920, 1080); //Clear the canvas

        let container = document.getElementById("container");

        let back = document.createElement("div");
        back.id = "back";
        back.innerText = "ðŸ¡„";
        back.onclick = () => window.location.reload();
        container.append(back);

        let left = document.createElement("div");
        let right = document.createElement("div");
        left.id = "prevMap";
        right.id = "nextMap";
        left.innerText = "â—€";
        right.innerText = "â–¶";
        left.onclick = () => {
          (mapIndex == 0) ? mapIndex = maps.length - 1 : mapIndex--;
          switchMap();
        }
        right.onclick = () => {
          (mapIndex == maps.length - 1) ? mapIndex = 0 : mapIndex++;
          switchMap();
        }
        container.append(left);
        container.append(right);

        let difficultyButtons = document.createElement("div");
        difficultyButtons.id = "difficulty";
        difficultyButtons.innerText = "Difficulty: ";
        let normal = document.createElement("button");
        let hard = document.createElement("button");
        normal.id = "normal";
        hard.id = "hard";
        normal.innerText = "Normal";
        hard.innerText = "Hard";
        normal.onclick = () => {
          difficulty = "normal";
          switchDifficulty();
        };
        hard.onclick = () => {
          difficulty = "hard";
          switchDifficulty();
        };
        container.append(difficultyButtons);
        document.getElementById("difficulty").append(normal);
        document.getElementById("difficulty").append(hard);

        let startButton = document.createElement("button");
        startButton.id = "startButton";
        startButton.classList.add("hCentered");
        startButton.innerText = "Start game";
        container.append(startButton);

        switchMap();

        document.getElementById("game").onclick = null;
      }
      document.getElementById("game").onclick = showMaps;

      function switchMap() {
        map = maps[mapIndex];
        ctx.clearRect(480, 0, 960, 570);
        ctx.fillStyle = "white";
        ctx.font = "48px Segoe UI";
        ctx.textAlign = "center";
        ctx.fillText(`${map.name} by ${map.author}`, 960, 75);
        ctx.drawPreview(map); //Draw preview of map
        ctx.strokeStyle = "white";
        ctx.lineWidth = 2;
        ctx.strokeRect(480, 120, 960, 450);
        switchDifficulty();
      }

      function switchDifficulty() {
        let normal = document.getElementById("normal");
        let hard = document.getElementById("hard");
        let startButton = document.getElementById("startButton");
        let mapComplete = +progress[mapIndex];
        ctx.clearRect(0, 675, 1920, 275);
        ctx.fillStyle = "white";
        ctx.font = "30px Segoe UI";
        if (difficulty == "normal") {
          normal.classList.add("pressed");
          hard.classList.remove("pressed");
          ctx.fillText("â€¢ 50 waves", 960, 700);
          ctx.fillText("â€¢ 100 lives", 960, 750);
          if (mapComplete) {
            ctx.fillStyle = "#80ff80";
            ctx.fillText("âœ”ï¸ Normal mode complete", 960, 935);
          }
        } else {
          hard.classList.add("pressed");
          normal.classList.remove("pressed");
          ctx.fillText("â€¢ 75 waves", 960, 700);
          ctx.fillText("â€¢ 50 lives", 960, 750);
          ctx.fillText("â€¢ No special powers", 960, 800);
          ctx.fillText("â€¢ Fast forward permanently on", 960, 850);
          if (mapComplete == 2) {
            ctx.fillStyle = "#80ff80";
            ctx.fillText("âœ”ï¸ Hard mode complete", 960, 935);
          } else if (!mapComplete) {
            ctx.fillStyle = "#ff6860";
            ctx.fillText("ðŸ”’ Complete normal mode to unlock hard mode", 960, 935);
            startButton.classList.add("unselectable");
            startButton.onclick = null;
          }
        }
        if (difficulty == "normal" || mapComplete) {
          startButton.classList.remove("unselectable");
          startButton.onclick = startGame;
        }
      }

      function startGame() {
        //Alerts for maps with errors
        let errorMessage;
        if (!map.start || map.start.length != 2) errorMessage = "No start position given.";
        else if (!map.start.every(pos => Math.abs(pos % 1) == 0.5)) errorMessage = "Invalid start position. Path must start in the middle of a square.";
        else if (!map.lines || !map.lines.length) errorMessage = "No path given.";
        else if (!map.lines.every(line => ["up", "down", "left", "right"].includes(line[0]) && !isNaN(line[1]))) errorMessage = "Invalid path. Use the format [direction, length] for each segment of the path.";
        else if (!Array.isArray(map.waves)) errorMessage = "No waves included.";
        else if (map.waves.length < 75) errorMessage = "Not enough waves. Maps must include 75 waves.";
        else if (map.waves.length > 75) errorMessage = "Too many waves. Maps must include 75 waves.";
        else if (!map.waves.every(wave => Array.isArray(wave))) errorMessage = "Each wave must be contained inside an array.";
        if (errorMessage) {
          gameAlert("<b>Map error:</b> " + errorMessage, false, true);
          return;
        }

        document.getElementById("back").remove();
        document.getElementById("prevMap").remove();
        document.getElementById("nextMap").remove();
        document.getElementById("difficulty").remove();
        document.getElementById("startButton").remove();

        grid[0].fill("button", 0, (difficulty == "normal") ? 5 : 4); //Buttons in to top left
        grid[0].fill("info", 26, 32); //Area for game info in the top right

        //Make an array with one item for each pixel of the path
        mapArr = [];
        map.lines.forEach(line => {
          for (let i = 0; i < line[1] * 60; i++) mapArr.push(line[0]);
        });

        map.waves.forEach(wave => wave.unshift([8, pause])); //Add a break at the start of each wave

        planePathArr = mapArr.slice(60, -60); //Remove start and end for plane path
        //Make the plane return to the start once it reaches the end
        for (let i = planePathArr.length - 1; i >= 0; i--) {
          switch (planePathArr[i]) {
            case "right":
              planePathArr.push("left");
              break;
            case "left":
              planePathArr.push("right");
              break;
            case "down":
              planePathArr.push("up");
              break;
            case "up":
              planePathArr.push("down");
          }
        }

        superPlanePathArr = [];
        //SuperPlane moves from end to start
        for (let i = mapArr.length - 1; i >= 0; i--) {
          switch (mapArr[i]) {
            case "right":
              superPlanePathArr.push("left");
              break;
            case "left":
              superPlanePathArr.push("right");
              break;
            case "down":
              superPlanePathArr.push("up");
              break;
            case "up":
              superPlanePathArr.push("down");
          }
        }

        if (difficulty == "normal") {
          map.waves.splice(-25, 25); //Remove the last 25 waves
          animate = setInterval(update, 40); //Start the game at normal speed
        } else {
          player.lives = 50;
          fastForward = true;
          animate = setInterval(update, 10); //Start the game at a 4x speed
        }

        //Create the grid
        document.getElementById("grid").classList.remove("hidden")
        let gridHTML = "";
        grid.forEach((row, i) => {
          gridHTML += "<tr>"; //For every array in grid, add a row to the table
          row.forEach((square, j) => gridHTML += `<td id="r${i}c${j}"></td>`); //For every item in the array, add a cell to the row. If the item is not null, set the cell's class to the item's value
          gridHTML += "</tr>";
        });
        document.getElementById("grid").innerHTML = gridHTML;

        //Show the towers
        document.getElementById("towers").classList.remove("hidden");
        for (let tower in towerTypes) {
          document.getElementById("towers").innerHTML += `<img src="../../static/img/towerdefense/${tower}.png" id="${tower}">`;
          document.getElementById("powers").innerHTML += `<button id="${tower}Power" class="invisible">Use power</button>`;
        }
        for (let tower in towerTypes) {
          let towerEl = document.getElementById(tower);
          let powerButton = document.getElementById(tower + "Power");
          let power = towerTypes[tower].power;
          towerEl.onmouseover = () => document.getElementById("towerDesc").innerText = `${towerTypes[tower].name} Â· $${towerTypes[tower].price} Â· ${towerTypes[tower].description}`;
          towerEl.onmouseout = () => document.getElementById("towerDesc").innerText = null;
          powerButton.style.color = towerTypes[tower].color;
          powerButton.onmouseover = () => document.getElementById("towerDesc").innerText = power.description;
          powerButton.onmouseout = () => document.getElementById("towerDesc").innerText = null;
          powerButton.onclick = () => {
            if (power.bought && !power.cooldown && towers.find(owned => owned?.name == towerTypes[tower].name) && difficulty == "normal") {
              power.use();
              power.cooldown = 3000;
              power.used = true;
              if (Object.values(towerTypes).every(tower => tower.power.used)) gameAchievements[3] = 1;
            }
          };
        }

        this.onclick = null;
      };

      function gameAlert(message, large, error) {
        document.getElementById("r0c3")?.click(); //Pause the game
        let alertBox = document.createElement("div");
        alertBox.id = "alert";
        alertBox.classList.add("centered");
        alertBox.classList.add("light");
        if (large) alertBox.classList.add("large");
        if (error) alertBox.classList.add("error");
        let alertText = document.createElement("div");
        alertText.id = "alertText";
        alertText.innerHTML = message;
        alertBox.append(alertText);
        let okButton = document.createElement("button");
        okButton.id = "ok";
        okButton.innerText = "OK";
        okButton.onclick = hideAlert;
        alertBox.append(okButton);
        document.getElementById("container").append(alertBox);
        document.addEventListener("keydown", hideAlert);
      }

      function hideAlert() {
        document.getElementById("alert").remove(); //Hide the alert box
        if (paused) document.getElementById("r0c0").click(); //Unpause the game
        document.removeEventListener("keydown", hideAlert);
      }

      function endGame(complete) {
        if (complete) {
          sound.playSFX("success");
          let num = (difficulty == "hard") ? 2 : 1;
          if (progress[mapIndex] < num) progress.splice(mapIndex, 1, num); //Update progress
          //Save to the database as a string
          let request1 = new XMLHttpRequest();
          request1.open("POST", "/updateuser?field=tdProgress&value=" + progress.join(""));
          request1.send();
        } else {
          sound.playSFX("shoot");
          gameAchievements[4] = 0;
          gameAchievements[5] = 0;
          gameAchievements[6] = 0;
        }
        let allAchievements = achievements.map((achievement, i) => +achievement || gameAchievements[i]); //New achievements + ones that were earned before
        let request2 = new XMLHttpRequest();
        request2.open("POST", "/updateuser?field=tdAchievements&value=" + allAchievements.join(""));
        request2.send();
        completeMaps = progress.reduce((a, b) => +a + +b);
        completeAchv = achievements.reduce((a, b) => +a + +b);
        let totalComplete = completeMaps + completeAchv;
        if (totalComplete) {
          let request3 = new XMLHttpRequest();
          request3.open("POST", "/savescore?game=towerdefense&score=" + totalComplete);
          request3.send();
        }
        //If a tower has a menu open, close it
        let menuTower = towers.find(tower => tower?.menuOpen);
        menuTower?.closeMenu();
        clearInterval(animate);
        ctx.clearRect(0, 0, 1920, 1080); //Clear the canvas
        document.getElementById("grid").classList.add("hidden");
        document.getElementById("towers").classList.add("hidden");
        ctx.fillStyle = "white";
        ctx.font = "128px Segoe UI";
        ctx.textAlign = "center";
        ctx.fillText(complete ? "Map complete!" : "Game over", 960, 300);
        ctx.font = "64px Segoe UI";
        ctx.fillStyle = "#80ffff";
        ctx.fillText(complete ? `${map.name} cleared on ${difficulty} mode` : `You lost on wave ${currentWave + 1}`, 960, 500);
        ctx.fillStyle = "#ffdf40";
        let newAchievements = achievements.filter((achievement, i) => !+achievement && gameAchievements[i]).length;
        if (newAchievements) ctx.fillText(`${newAchievements} new ${(newAchievements == 1) ? "achievement" : "achievements"} earned`, 960, 600);
        ctx.font = "48px Segoe UI";
        ctx.fillStyle = "white";
        ctx.fillText("Click to return to the home screen", 960, 800);
        document.getElementById("game").onclick = () => window.location.reload();
      }
    }
  </script>
{% endblock %}
